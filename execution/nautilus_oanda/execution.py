"""
nautilus_oanda.execution
------------------------

Execution client for OANDA (orders & positions).
"""

import asyncio
from decimal import Decimal
from typing import Optional

import oandapyV20
import oandapyV20.endpoints.orders as orders
import oandapyV20.endpoints.transactions as transactions
from nautilus_trader.common.component import LiveExecutionClient
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.enums import OrderType
from nautilus_trader.model.enums import TimeInForce
from nautilus_trader.model.events import OrderFilled
from nautilus_trader.model.objects import Currency
from nautilus_trader.model.orders import LimitOrder
from nautilus_trader.model.orders import MarketOrder
from nautilus_trader.model.orders import Order

from .config import OandaExecutionClientConfig
from .parsing import parse_datetime
from .parsing import parse_instrument_id


class OandaExecutionClient(LiveExecutionClient):
    """Handles execution (orders) on OANDA."""

    def __init__(
        self,
        loop: asyncio.AbstractEventLoop,
        config: OandaExecutionClientConfig,
        msgbus,
        cache,
        clock,
    ):
        super().__init__(loop, config, msgbus, cache, clock)
        self._config = config
        self._api = oandapyV20.API(
            access_token=config.access_token,
            environment=config.environment
        )
        self._account_id = config.account_id
        self._stream_task: Optional[asyncio.Task] = None

    async def connect(self):
        """Connect to OANDA transactions stream."""
        if self._stream_task:
            return
        self._stream_task = self._loop.create_task(self._stream_transactions())
        self._set_connected(True)

    async def disconnect(self):
        """Disconnect from OANDA stream."""
        if self._stream_task:
            self._stream_task.cancel()
            try:
                await self._stream_task
            except asyncio.CancelledError:
                pass
            self._stream_task = None
        self._set_connected(False)

    async def _stream_transactions(self):
        """Stream transaction events (fills, cancels)."""
        try:
            r = transactions.TransactionsStream(accountID=self._account_id)
            await self._loop.run_in_executor(None, self._consume_stream, r)
        except Exception as e:
            self._log.error(f"Transaction stream error: {e}")

    def _consume_stream(self, request):
        """Blocking loop to consume transactions."""
        try:
            for line in self._api.request(request):
                if line["type"] in ("ORDER_FILL", "ORDER_CANCEL", "ORDER_CREATE"):
                    self._loop.call_soon_threadsafe(self._handle_event, line)
        except Exception as e:
            self._log.error(f"Transaction stream failed: {e}")

    def _handle_event(self, data: dict):
        """Process OANDA transaction event."""
        # TODO: Map OANDA event to Nautilus OrderEvent
        # This requires robust mapping of OrderID, ClientOrderID, etc.
        pass

    async def submit_order(self, order: Order):
        """Submit an order to OANDA."""
        # 1. Map Nautilus Order to OANDA dict
        data = self._map_order(order)
        
        # 2. Send request
        r = orders.OrderCreate(self._account_id, data=data)
        
        try:
            # Run blocking request in executor
            response = await self._loop.run_in_executor(
                None, lambda: self._api.request(r)
            )
            self._log.info(f"Order submitted: {response}")
            # OrderSubmitted event is generated by Nautilus core usually?
            # Or we confirmation here.
            
        except Exception as e:
            self._log.error(f"Order submission failed: {e}")
            # Generate OrderRejected event

    def _map_order(self, order: Order) -> dict:
        """Map Nautilus order to OANDA API format."""
        
        # OANDA expects:
        # {
        #   "order": {
        #     "units": "100",
        #     "instrument": "EUR_USD",
        #     "timeInForce": "FOK",
        #     "type": "MARKET",
        #     "positionFill": "DEFAULT"
        #   }
        # }
        
        units = int(order.quantity)
        if order.side == OrderSide.SELL:
            units = -units
            
        oanda_symbol = order.instrument_id.symbol.value.replace("/", "_")
        
        order_type = "MARKET"
        price = None
        if isinstance(order, LimitOrder):
            order_type = "LIMIT"
            price = f"{order.price}"
            
        data = {
            "order": {
                "units": str(units),
                "instrument": oanda_symbol,
                "type": order_type,
                "clientExtensions": {
                    "id": str(order.client_order_id),
                    "tag": "nautilus",
                }
            }
        }
        
        if price:
            data["order"]["price"] = price
            data["order"]["timeInForce"] = "GTC" # Limit orders usually GTC
            
        return data

    async def cancel_order(self, command):
        """Cancel an order."""
        # Implementation via updates to existing orders
        pass
